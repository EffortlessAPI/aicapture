/*******************************************
 Initially Generated by SSoT.me - codee42 & odxml42
 Created By: EJ Alexandra - 2017
             An Abstract Level, llc
 License:    Mozilla Public License 2.0
 *******************************************/
using System;
using System.ComponentModel;
using SassyMQ.SSOTME.Lib.RMQActors;
using System.IO;
using Newtonsoft.Json;
using SassyMQ.Lib.RabbitMQ;
using System.Linq;
using SSoTme.OST.Lib.Extensions;
using System.Xml;
using System.Diagnostics;
using System.Collections.Generic;
//using System.Windows.Forms;
using System.Threading;

namespace SSoTme.OST.Lib.DataClasses
{
    public partial class SSoTmeProject
    {
        public List<string> HiddenPaths { get; set; }
        public List<string> ExpandedPaths { get; set; }
        public bool ShowHidden { get; set; }
        private string _currentPath;
        public bool ShowAllFiles { get; set; }
        public string CurrentPath
        {
            get => _currentPath;
            set
            {
                if (!String.Equals(_currentPath, value, StringComparison.OrdinalIgnoreCase))
                {
                    if (String.IsNullOrEmpty(_currentPath) || !String.IsNullOrEmpty(value))
                    {
                        _currentPath = value;
                        this.OnCurrentPathChanged(EventArgs.Empty);
                    }
                }
            }
        }
        private FileSystemWatcher _projectMonitor;

        protected FileSystemWatcher ProjectMonitor
        {
            get => _projectMonitor;
            set
            {
                if (!ReferenceEquals(_projectMonitor, null)) this.UnwireProjectMonitor();
                _projectMonitor = value;
                if (!ReferenceEquals(_projectMonitor, null)) this.WireProjectMonitor();
            }
        }

        public bool SaveDisabled { get; private set; }

        private void WireProjectMonitor()
        {
            this.ProjectMonitor.IncludeSubdirectories = true;
            this.ProjectMonitor.EnableRaisingEvents = true;
            this.ProjectMonitor.Changed += ProjectMonitor_Changed;
            this.ProjectMonitor.NotifyFilter = this.ProjectMonitor.NotifyFilter | NotifyFilters.LastAccess;
        }

        public void DisableSave()
        {
            this.SaveDisabled = true;
        }

        public void EnableSave()
        {
            this.SaveDisabled = false;
        }

        private void ProjectMonitor_Changed(object sender, FileSystemEventArgs e)
        {
            if (String.Equals(Path.GetFileName(e.FullPath), "aicapture.json", StringComparison.OrdinalIgnoreCase))
            {
                //var form = Application.OpenForms.OfType<Form>().FirstOrDefault();
                //if (ReferenceEquals(form, null) || !form.InvokeRequired) this.OnProjectFileReloaded(this, e);
                //else
                //{
                //    try
                //    {
                //        form.Invoke(new EventHandler<FileSystemEventArgs>(this.OnProjectFileReloaded), this, e);
                //    }
                //    catch (ObjectDisposedException ode)
                //    {
                //        // ignore disposed errors...
                //    }
                //}
            }
        }

        public event EventHandler<FileSystemEventArgs> ProjectFileReloaded;
        protected virtual void OnProjectFileReloaded(object sender, FileSystemEventArgs e)
        {
            if (!ReferenceEquals(this.ProjectFileReloaded, null))
            {
                this.ProjectFileReloaded(sender, e);
            }
        }

        private void UnwireProjectMonitor()
        {
            this.ProjectMonitor.Changed -= ProjectMonitor_Changed;
        }

        public event EventHandler CurrentPathChanged;
        protected virtual void OnCurrentPathChanged(EventArgs eventArgs)
        {
            if (!ReferenceEquals(this.CurrentPathChanged, null))
            {
                this.CurrentPathChanged(this, eventArgs);
            }
        }

        public SSoTmeProject()
        {
            this.HiddenPaths = new List<String>();
            this.ExpandedPaths = new List<String>();
            this.SaveDisabled = false;
            this.InitPoco();
        }

        public static void Init(bool force = false, String projectName = "")
        {

            var currentProject = TryToLoad(new DirectoryInfo(Environment.CurrentDirectory));


            if (!ReferenceEquals(currentProject, null) && !force)
            {
                if (!String.IsNullOrEmpty(projectName))
                {
                    currentProject.Name = projectName.SafeToString().Replace(" ", "");
                    currentProject.Save();
                }
                else throw new Exception(String.Format("Project has already been initialized in: {0}", currentProject.RootPath));
            }
            else
            {
                projectName = String.IsNullOrEmpty(projectName) ? Path.GetFileName(Environment.CurrentDirectory) : projectName;
                var newProject = new SSoTmeProject();
                newProject.RootPath = Environment.CurrentDirectory;
                newProject.Name = projectName;
                newProject.AddGitIgnore();
                newProject.Save();
            }

            var ssotFI = new FileInfo(Path.Combine(Environment.CurrentDirectory, "SSoT", "single-source-of-truth.json"));
            if (!ssotFI.Directory.Exists) ssotFI.Directory.Create();
            if (!ssotFI.Exists) File.WriteAllText(ssotFI.FullName, $"{{\"project\":\n  {{\n    \"name\":\"{projectName}\"\n  }}\n}}");
        }

        private void AddGitIgnore()
        {
            var fi = new FileInfo(Path.Combine(this.RootPath, ".gitignore"));
            if (!fi.Exists)
            {
                var gitIgnore = @"/**/obj/**/*
/**/bin/**/*
/.ssotme/**/*
/DSPXml/**/*
/SSoT/__patch.json
/AICapture/Backup/*.zip";
                File.WriteAllText(fi.FullName, gitIgnore);
            }
        }

        public bool IsExpanded(DirectoryInfo directoryToCheck)
        {
            var relativePath = this.GetProjectRelativePath(directoryToCheck);
            return this.ExpandedPaths.Contains(relativePath);

        }

        public void Expand(DirectoryInfo directoryInfo)
        {
            if (!this.IsExpanded(directoryInfo))
            {
                var relativePath = this.GetProjectRelativePath(directoryInfo);
                this.ExpandedPaths.Add(relativePath);
                this.Save();
            }

        }

        public void Collapse(DirectoryInfo directoryInfo)
        {
            if (this.IsExpanded(directoryInfo))
            {
                var relativePath = this.GetProjectRelativePath(directoryInfo);
                while (this.ExpandedPaths.Any(anyPath => anyPath.Equals(relativePath)))
                {
                    this.ExpandedPaths.Remove(relativePath);
                }
            }
        }

        public bool IsHidden(DirectoryInfo directoryInfo)
        {
            return this.HiddenPaths.Contains(this.GetProjectRelativePath(directoryInfo));
        }

        public void ShowNode(DirectoryInfo directoryInfo)
        {
            var relativePath = this.GetProjectRelativePath(directoryInfo);
            this.HiddenPaths.Remove(relativePath);
            this.LogMessage("Directory Shown {0}", relativePath);
        }

        public class LogEventArgs : EventArgs
        {
            public LogEventArgs(String message, params object[] args)
            {
                this.Message = String.Format(message, args);
            }

            public string Message { get; }
        }
        public event EventHandler<LogEventArgs> MessageLogged;
        public void LogMessage(string formatString, params object[] args)
        {
            Console.WriteLine(formatString, args);

            if (!ReferenceEquals(this.MessageLogged, null))
            {
                this.MessageLogged(this, new LogEventArgs(formatString, args));
            }

        }

        public void HideNode(DirectoryInfo directoryInfo)
        {
            var relativePath = this.GetProjectRelativePath(directoryInfo);
            this.HiddenPaths.Add(relativePath);
            this.LogMessage("Directory Hidden {0}", relativePath);
        }

        public void Save()
        {
            if (this.SaveDisabled) throw new Exception("Saving is currently disabled...");
            this.Save(new DirectoryInfo(this.RootPath));
            this.LogMessage("Project saved");
        }

        private void Save(DirectoryInfo rootDI)
        {
            this.CheckUniqueIDs();
            this.AddSetting(string.Format("project-name={0}", this.Name));
            this.ProjectTranspilers
                .ToList()
                .ForEach(feProjectTranspiler =>
                {
                    if (feProjectTranspiler.MatchedTranspiler == null) feProjectTranspiler.MatchedTranspiler = new Transpiler();
                    feProjectTranspiler.MatchedTranspiler = new Transpiler()
                    {
                        TranspilerId = feProjectTranspiler.MatchedTranspiler.TranspilerId,
                        Name = feProjectTranspiler.MatchedTranspiler.Name,
                        Description = feProjectTranspiler.MatchedTranspiler.Description,
                        TranspileRequests = null,
                        TranspilerInstances = null,
                        TranspilerVersions = null
                    };
                });
            string projectJson = JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
            var tempTranspiler = JsonConvert.DeserializeObject<SSoTmeProject>(projectJson);
            tempTranspiler.RootPath = null;
            if (!ReferenceEquals(tempTranspiler.ExpandedPaths, null) &&
                    !tempTranspiler.ExpandedPaths.Any()) tempTranspiler.ExpandedPaths = null;
            if (!ReferenceEquals(tempTranspiler.HiddenPaths, null) &&
                    !tempTranspiler.HiddenPaths.Any()) tempTranspiler.HiddenPaths = null;
            projectJson = JsonConvert.SerializeObject(tempTranspiler, Newtonsoft.Json.Formatting.Indented, new JsonSerializerSettings()
            {
                NullValueHandling = NullValueHandling.Ignore
            });
            var count = 0;
            while (count < 5)
            {
                try
                {
                    File.WriteAllText(this.GetProjectFileName(), projectJson);
                    break;
                }
                catch (System.IO.IOException ioex)
                {
                    count++;
                    Thread.Sleep(500);
                }
            }
        }

        public void CheckUniqueIDs()
        {
            IEnumerable<ProjectTranspiler> dupTranspilers = GetDuplicateTranpsilers();
            while (dupTranspilers.Any())
            {
                var firstDup = dupTranspilers.First();
                firstDup.ProjectTranspilerId = Guid.NewGuid();
                dupTranspilers = GetDuplicateTranpsilers();
            }

            foreach (var transpiler in this.ProjectTranspilers.Where(wherePT => !ReferenceEquals(wherePT.MatchedTranspiler, null)))
            {
                transpiler.MatchedTranspiler.UsageCount = 0;
            }
        }

        private IEnumerable<ProjectTranspiler> GetDuplicateTranpsilers()
        {
            return this.ProjectTranspilers.Where(pt => this.ProjectTranspilers.Where(otherPT => otherPT != pt).Any(anyOtherPT => anyOtherPT.ProjectTranspilerId == pt.ProjectTranspilerId));
        }

        protected String GetProjectFileName()
        {
            return GetProjectFI().FullName;
        }

        protected FileInfo GetProjectFI()
        {
            return GetProjectFIAt(new DirectoryInfo(this.RootPath));
        }

        protected static FileInfo GetProjectFIAt(DirectoryInfo rootDI)
        {
            var aiCaptureProjectFI = new FileInfo(Path.Combine(rootDI.FullName, "aicapture.json"));
            if (!aiCaptureProjectFI.Exists)
            {
                var ssotmeFI = new FileInfo(Path.Combine(rootDI.FullName, "SSoTmeProject.json"));
                if (ssotmeFI.Exists) ssotmeFI.MoveTo(Path.Combine(rootDI.FullName, "aicapture.json"));
            }

            return aiCaptureProjectFI;
        }

        private static AICaptureProject Load(FileInfo projectFI, DirectoryInfo requestDirectory = null, bool updateCurrent = true)
        {
            var count = 0;
            while (count++ < 10)
            {
                try
                {
                    var projectJson = File.ReadAllText(projectFI.FullName);
                    var ssotmeProject = JsonConvert.DeserializeObject<AICaptureProject>(projectJson);
                    ssotmeProject.RootPath = projectFI.Directory.FullName;
                    if (String.IsNullOrEmpty(ssotmeProject.Name))
                    {
                        ssotmeProject.Name = Path.GetFileName(ssotmeProject.RootPath);
                    }

                    if (updateCurrent) ssotmeProject.SetCurrentFromRequestDirectory(requestDirectory);

                    return ssotmeProject;

                }
                catch (IOException ioex)
                {
                    Thread.Sleep(500);
                }
            }

            throw new Exception("Unable to load project file: " + projectFI.FullName);

        }

        public void MonitorProjectFile()
        {
            var projectFI = this.GetProjectFI();
            if (projectFI.Exists)
            {
                this.ProjectMonitor = new FileSystemWatcher(projectFI.Directory.FullName);
                //this.ProjectMonitor.Filter = "SSoTmeProject.json";
            }
            else this.ProjectMonitor = null;

        }

        public void StopMonitoringProjectFile()
        {
            this.ProjectMonitor = null;
        }

        private void SetCurrentFromRequestDirectory(DirectoryInfo requestDirectory)
        {
            this.CurrentPath = this.GetProjectRelativePath(requestDirectory);

        }

        public static SSoTmeProject LoadOrFail(DirectoryInfo dirToCheck, bool updateCurrent = true)
        {
            var proj = TryToLoad(dirToCheck, dirToCheck, updateCurrent);

            if (ReferenceEquals(proj, null))
            {
                throw new Exception(String.Format("AICapture Project file could not be found in {0}.  \n\nPlease run `>aicapture -init` from the root of your project to initialize the SSoTme Project.", dirToCheck.FullName));
            }
            else return proj;
        }

        internal DirectoryInfo GetZFSDI(string relativePath)
        {
            var ssotmeDI = (DirectoryInfo)this.GetSSoTmeDI();
            var zfsDI = new DirectoryInfo(Path.Combine(ssotmeDI.FullName, relativePath.Trim("\\/".ToCharArray())));
            if (!zfsDI.Exists) zfsDI.Create();
            return zfsDI;
        }

        private DirectoryInfo GetSSoTmeDI()
        {
            var ssotmeDI = new DirectoryInfo(Path.Combine(this.RootPath, ".ssotme"));
            if (ssotmeDI.Exists)
            {
                ssotmeDI.Create();
                ssotmeDI.Attributes = FileAttributes.Directory | FileAttributes.Hidden;
            }
            return ssotmeDI;

        }

        public static AICaptureProject TryToLoad(DirectoryInfo dirToCheck, DirectoryInfo requestDirectory = null, bool updateCurrent = true)
        {
            FileInfo projectFI = GetProjectFIAt(dirToCheck);

            if (ReferenceEquals(requestDirectory, null)) requestDirectory = dirToCheck;

            if (projectFI.Exists) return SSoTmeProject.Load(projectFI, requestDirectory, updateCurrent);
            else
            {
                // Try parent
                if (ReferenceEquals(dirToCheck.Parent, null)) return default(AICaptureProject);
                else return TryToLoad(dirToCheck.Parent, requestDirectory, updateCurrent);
            }
        }

        private static SSoTmeProject Load(DirectoryInfo rootDI)
        {
            return Load(GetProjectFIAt(rootDI));
        }

        public void AddSetting(string setting)
        {
            var partsOfSetting = setting.SafeToString().Split("=".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

            var settingName = partsOfSetting.FirstOrDefault();
            var settingValue = String.Join(String.Empty, partsOfSetting.Skip(1));

            if (string.IsNullOrEmpty(settingName)) throw new Exception("Settings must be in the format of 'name=value'");
            else
            {
                var currentSettings = this.ProjectSettings.Where(whereSetting => String.Equals(whereSetting.Name, settingName, StringComparison.OrdinalIgnoreCase));

                var addSetting = true;

                if ((currentSettings.Count() == 1) && (currentSettings.First().Value == settingValue))
                {
                    addSetting = false;
                }

                if (addSetting)
                {
                    currentSettings.ToList().ForEach(feSettingToRemove => this.ProjectSettings.Remove(feSettingToRemove));

                    this.ProjectSettings.Add(new ProjectSetting()
                    {
                        Name = settingName,
                        Value = settingValue
                    });
                    this.LogMessage("Added Setting: {0}: '{1}'", settingName, settingValue);
                }

                if (String.Equals(settingName, "project-name", StringComparison.OrdinalIgnoreCase))
                {
                    if (!String.IsNullOrEmpty(settingValue) && (settingValue != this.Name)) this.Name = settingValue;
                }
            }
        }

        internal void ListSettings()
        {
            this.LogMessage("\nSETTINGS: ");

            if (this.ProjectSettings.Any())
            {
                foreach (var projectSetting in this.ProjectSettings)
                {
                    this.LogMessage("    - {0} = {1}", projectSetting.Name, projectSetting.Value);
                }
            }
            else this.LogMessage("NO settings added to the project yet.");
        }

        public void CheckResults()
        {

            this.LogMessage("Updating transpilers/inputs/outputs and project flow...");

            // Load each tranpspiler and load it's input and output files.
            foreach (var projectTranspiler in this.ProjectTranspilers)
            {
                var ptDI = new DirectoryInfo(Path.Combine(this.RootPath, projectTranspiler.RelativePath.Trim("\\/".ToCharArray())));
                if (!ptDI.Exists) ptDI.Create();
                Environment.CurrentDirectory = Path.Combine(this.RootPath, projectTranspiler.RelativePath.Trim("\\/".ToCharArray()));

                projectTranspiler.LoadInputAndOuputFiles(this, false);
            }

            var json = JsonConvert.SerializeObject(this);
            json = String.Format("{{ \"{0}\" : {1} }}", this.GetName(), json);
            var xml = json.JsonToXml();
            DirectoryInfo di = new DirectoryInfo(Path.Combine(this.RootPath, "DSPXml"));
            if (!di.Exists) di.Create();
            var count = 0;

            while (count < 5)
            {
                try
                {
                    File.WriteAllText(Path.Combine(di.FullName, "SSoTmeProject.spxml"), xml.OuterXml);
                    break;
                }
                catch (System.IO.IOException ioex)
                {
                    count++;
                    Thread.Sleep(500);
                }
            }
        }

        public void CreateDocs()
        {
            this.LogMessage("Updating Docs from latest SPXml results.");

            this.CheckResults();


            DirectoryInfo di = new DirectoryInfo(Path.Combine(this.RootPath, "DSPXml"));
            if (!di.Exists) di.Create();

            Environment.CurrentDirectory = di.FullName;

            ProcessStartInfo psi = new ProcessStartInfo("cmd");
            psi.WorkingDirectory = di.FullName;

            psi.Arguments = "/C aicapture spxml-to-detailed-spxml -i \"./SSoTmeProject.spxml\"";
            var p = Process.Start(psi);
            p.WaitForExit(100000);
            if (!p.HasExited) throw new Exception("Failed waiting for Detailed SP Xml to be created.");
            else
            {
                psi.Arguments = "/C aicapture detailed-spxml-to-html-docs -i \"./SSoTmeProject.dspxml\"";
                p = Process.Start(psi);

                p.WaitForExit(100000);
                if (!p.HasExited) throw new Exception("Failed waiting for Docs to be created.");
                else
                {
                    this.LogMessage("Analyze completed");
                }
            }

        }

        public string GetName()
        {
            if (String.IsNullOrEmpty(this.Name)) return Path.GetFileName(this.RootPath);
            else return this.Name;
        }

        public void Describe(string relativePath = "")
        {
            this.LogMessage("\n==========================================");
            this.LogMessage("======  {0}", this.Name);
            this.LogMessage("======    {0}", this.RootPath);
            this.LogMessage("==========================================");

            this.LogMessage(String.Empty);

            this.ListSettings();

            this.LogMessage(String.Empty);


            this.LogMessage("\nTRANSPILERS: ");
            var matchingProjectTranspilers = this.ProjectTranspilers.ToList();

            if (!String.IsNullOrEmpty(relativePath))
            {
                relativePath = this.GetProjectRelativePath(relativePath);
                matchingProjectTranspilers = matchingProjectTranspilers.Where(wherePT => wherePT.IsAtPath(relativePath)).ToList();
            }

            foreach (var projectTranspiler in matchingProjectTranspilers)
            {
                projectTranspiler.Describe(this);
            }
        }

        public void Install(SSOTMEPayload result, string transpilerGroup)
        {
            string relativePath = this.GetProjectRelativePath(Environment.CurrentDirectory);

            var projectTranspiler = new ProjectTranspiler(relativePath, result);
            projectTranspiler.TranspilerGroup = transpilerGroup;

            this.IntegrateNewTranspiler(projectTranspiler);

            this.Save();
        }

        internal void Update(ProjectTranspiler projectTranspiler, SSOTMEPayload result)
        {
            projectTranspiler.MatchedTranspiler = ReferenceEquals(result, null) ? default(Transpiler) : result.Transpiler;
            this.IntegrateExistingTranspiler(projectTranspiler);

            this.Save();
        }

        public string GetProjectRelativePath(DirectoryInfo di)
        {
            if (ReferenceEquals(di, null)) return "/";
            else return this.GetProjectRelativePath(di.FullName);
        }

        public string GetProjectRelativePath(String fullPath)
        {
            var relativePathDI = new DirectoryInfo(fullPath);
            var rootPathDI = new DirectoryInfo(this.RootPath);
            var relativePath = relativePathDI.FullName.Substring(rootPathDI.FullName.Length);
            return relativePath.Replace("\\", "/");
        }

        public void Rebuild(string buildPath, bool includeDisabled)
        {
            var currentDirectory = Environment.CurrentDirectory;
            try
            {
                var relativePath = this.GetProjectRelativePath(buildPath);
                var matchingProjectTranspilers = this.ProjectTranspilers.Where(wherePT => wherePT.IsAtPath(relativePath));
                foreach (var pt in matchingProjectTranspilers)
                {
                    if (!pt.IsDisabled || includeDisabled) pt.Rebuild(this);
                    else this.LogMessage("\n\n - SKIPPING DISABLED TRANSPILER: {0}\n - {1}\n - {2}\n\n", pt.Name, pt.RelativePath, pt.CommandLine);
                }
            }
            finally
            {
                Environment.CurrentDirectory = currentDirectory;
            }
        }


        public void Clean(bool preserveZFS)
        {
            this.Clean(this.RootPath, preserveZFS);
        }

        public void Clean(string cleanPath, bool preserveZFS)
        {
            var currentDirectory = Environment.CurrentDirectory;
            try
            {
                var relativePath = this.GetProjectRelativePath(cleanPath);
                var matchingProjectTranspilers = this.ProjectTranspilers.Where(wherePT => wherePT.IsAtPath(relativePath));
                foreach (var pt in matchingProjectTranspilers)
                {
                    pt.Clean(this, preserveZFS);
                }
            }
            finally
            {
                Environment.CurrentDirectory = currentDirectory;
            }
        }

        public void Rebuild(bool includeDisabled)
        {
            this.Rebuild(this.RootPath, includeDisabled);
        }


        private void IntegrateExistingTranspiler(ProjectTranspiler projectTranspiler)
        {
            this.IntegrateTranspiler(projectTranspiler, false);
        }

        private void IntegrateNewTranspiler(ProjectTranspiler projectTranspiler)
        {
            this.IntegrateTranspiler(projectTranspiler, true);
        }

        private void IntegrateTranspiler(ProjectTranspiler projectTranspiler, bool addIfMissing)
        {
            var matchingTranspiler = this.ProjectTranspilers.FirstOrDefault(fodPT => (fodPT.Name == projectTranspiler.Name) &&
                                                                                     (fodPT.RelativePath == projectTranspiler.RelativePath) &&
                                                                                     (String.IsNullOrEmpty(fodPT.TranspilerGroup) || String.Equals(fodPT.TranspilerGroup, projectTranspiler.TranspilerGroup)));
            int firstIndex = -1;
            while (!ReferenceEquals(matchingTranspiler, null))
            {
                if (firstIndex == -1) firstIndex = this.ProjectTranspilers.IndexOf(matchingTranspiler);
                this.ProjectTranspilers.Remove(matchingTranspiler);
                matchingTranspiler = this.ProjectTranspilers.FirstOrDefault(fodPT => (fodPT.Name == projectTranspiler.Name) && (fodPT.RelativePath == projectTranspiler.RelativePath));
            }
            if (firstIndex >= 0) this.ProjectTranspilers.Insert(firstIndex, projectTranspiler);
            else if (addIfMissing) this.ProjectTranspilers.Add(projectTranspiler);
            projectTranspiler.Name = projectTranspiler.MatchedTranspiler.Name;
        }


        public void RemoveSetting(string setting)
        {
            var partsOfSetting = setting.SafeToString().Split("=".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

            var settingName = partsOfSetting.FirstOrDefault();
            var settingValue = String.Join(String.Empty, partsOfSetting.Skip(1));

            if (string.IsNullOrEmpty(settingName)) throw new Exception("Setting name not provided - unable to remove.");
            else
            {
                var matchingSetting = this.ProjectSettings.FirstOrDefault(fodSetting => fodSetting.Name.Equals(settingName, StringComparison.OrdinalIgnoreCase));
                if (ReferenceEquals(matchingSetting, null)) throw new Exception(String.Format("Can't find matching setting: {0}", settingName));
                else
                {
                    this.ProjectSettings.Remove(matchingSetting);
                    this.LogMessage("Successfully Removed Setting: {0}: '{1}'", matchingSetting.Name, matchingSetting.Value);
                }
            }
        }
    }
}